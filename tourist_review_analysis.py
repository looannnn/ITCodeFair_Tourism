# -*- coding: utf-8 -*-
"""tourist_review_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Jxx7NXcVtGwhLhirhme_3geLzQB_c7YZ
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from transformers import pipeline, AutoModelForSequenceClassification, AutoTokenizer

df = pd.read_csv('/content/drive/MyDrive/data/top_attractions_NT.csv')
df.head()

df.columns

# Check which columns might contain review text for emotion classification
text_cols = [col for col in df.columns if "text" in col.lower() or "review" in col.lower() or "content" in col.lower()]
text_cols[:20], len(text_cols)

df['text'].head(10)

# Load the GoEmotions model
model_name = "joeddav/distilbert-base-uncased-go-emotions-student"
model = AutoModelForSequenceClassification.from_pretrained(model_name)

# Number of classes
num_labels = model.config.num_labels
print("Number of emotion classes:", num_labels)

# Label mapping (index -> emotion)
id2label = model.config.id2label
print(id2label)

import torch
print("CUDA available?", torch.cuda.is_available())
print("GPU name:", torch.cuda.get_device_name(0) if torch.cuda.is_available() else "CPU only")

# Load Hugging Face GoEmotions pipeline
emotion_classifier = pipeline(
    "text-classification",
    model="joeddav/distilbert-base-uncased-go-emotions-student",
    top_k=None,
    device=0
)

# Run classification for all reviews
all_reviews = df['text'].dropna().tolist()
results = emotion_classifier(all_reviews, truncation=True)

# Organize results
emotion_outputs = []
for review, res in zip(all_reviews, results):
    sorted_res = sorted(res, key=lambda x: x['score'], reverse=True)
    top_emotion = sorted_res[0]
    emotion_outputs.append({
        "top_emotion": top_emotion['label'],
        "confidence": round(top_emotion['score'], 3)
    })

# Add back to DataFrame
df.loc[df['text'].notna(), 'top_emotion'] = [eo['top_emotion'] for eo in emotion_outputs]
df.loc[df['text'].notna(), 'confidence'] = [eo['confidence'] for eo in emotion_outputs]

df[['text', 'top_emotion', 'confidence']].head(10)

from collections import defaultdict

# Define mapping (GoEmotions â†’ 7 core)
emotion_mapping = {
    "joy": ["amusement", "excitement", "joy", "love", "desire", "optimism", "relief", "pride", "admiration", "approval", "caring", "gratitude"],
    "anger": ["anger", "annoyance", "disapproval"],
    "sadness": ["disappointment", "embarrassment", "grief", "remorse", "sadness"],
    "fear": ["fear", "nervousness"],
    "surprise": ["realization", "surprise", "curiosity", "confusion"],
    "disgust": ["disgust"],
    "neutral": ["neutral"]
}

# Invert mapping for quick lookup
fine_to_core = {fine: core for core, fine_list in emotion_mapping.items() for fine in fine_list}

collapsed_outputs = []
for review, res in zip(all_reviews, results):
    # Aggregate scores into 7 groups
    group_scores = defaultdict(float)
    for r in res:
        fine_label = r['label']
        score = r['score']
        if fine_label in fine_to_core:
            core_label = fine_to_core[fine_label]
            group_scores[core_label] += score

    # Pick top group
    top_group = max(group_scores.items(), key=lambda x: x[1])

    collapsed_outputs.append({
        "review_preview": review[:80] + ("..." if len(review) > 80 else ""),
        "collapsed_emotion": top_group[0],
        "confidence": round(top_group[1], 3),
    })

collapsed_df = pd.DataFrame(collapsed_outputs)

# Get the indices of reviews we classified
valid_idx = df['text'].dropna().index

# Add new columns
df.loc[valid_idx, 'core_emotion'] = collapsed_df['collapsed_emotion'].values
df.loc[valid_idx, 'core_confidence'] = collapsed_df['confidence'].values

df[['text', 'core_emotion', 'core_confidence']].head(10)

plt.figure(figsize=(8,6))
sns.countplot(data=df, x='core_emotion', order=df['core_emotion'].value_counts().index, palette="viridis", hue='core_emotion', legend=False)

plt.title("Distribution of Core Emotions in Tripadvisor Reviews")
plt.xlabel("Core Emotion")
plt.ylabel("Number of Reviews")
plt.xticks(rotation=45)
plt.show()

plt.figure(figsize=(8,10))
sns.countplot(
    data=df,
    y="top_emotion",
    order=df['top_emotion'].value_counts().index,
    palette="viridis",
    hue="top_emotion",
    legend=False
)

plt.title("Distribution of Fine-Grained Emotions", fontsize=14, weight="bold")
plt.xlabel("Number of Reviews")
plt.ylabel("Top Emotion")
plt.show()